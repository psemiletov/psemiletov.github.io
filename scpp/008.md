### ПЕТР СЕМИЛЕТОВ

### ПРОСТО С++: УРОК 8, ПРОСТАЯ МАТЕМАТИКА

  Чтобы двигаться дальше, нам нужно обсудить некоторые тонкости использования в С++ простейших математических действий вроде сложения, вычитания, умножения и деления.

   Допустим, мы хотим к значению переменной **х** прибавить 2. В первой строке объявим **х** равным 1 и во второй строке прибавим к нему 2:

```cpp
int x = 1;
x = x + 2; 
```

   В итоге **х** станет равным 3.

   Можно ли вторую строку записать короче? Да, вот так:

```cpp
x += 2;
```

   В очередной раз напомню, что операндами, то есть тем, с чем вы оперируете, слева от знака равенства могут быть только переменные, а справа - со всеми остальными знаками вроде +, -, /, * - и переменные, и сами числа. 

   При использовании переменной в таком случае операндом служит значение переменной, то есть содержащееся в ней число. После выражения не забывайте ставить точку с запятой.

   Рассмотрим вычитание. Сходным образом:

```cpp
int x = 1;
x = x - 2; 
```

   Тут от **х** мы отнимаем 2. Либо, сокращенно:

```cpp
x -= 2;
```

   Умножение. Для умножения используется знак *.

```cpp
int x = 2;
x = x * 2; 
```

   или:

```cpp
x *= 2; 
```

   Деление. Для деления служит оператор /. При делении чисел могут возникать дробные числа. Однако, если результат записывается в переменную целого типа, такого как **int**, то результат не округляется согласно правилам округления, но получается отбрасыванием дробной части:

```cpp
int x = 16 / 5;
```

**х** будет равен 3.


Полезно пробовать сказанное далее на примере 08-01.cpp:

#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
  int x = 16 / 5;

  cout << x << endl;

  return 0;
}

   Привычно идем в консоли в каталог с файлом, компилируем:

g++ 08-01.cpp

Запускаем. Под линуксом:

./a.out

Под вындой:

a.exe

Жмем энтер.

Так, на экран вывелось "3".

   А что, если мы хотим работать с дробями? Казалось бы, достаточно заменить тип Х с целочисленного int на дробный float:

   float x = 16 / 5;

   Что же, пробуем...
   Черт, снова выдает тройку. В чем же дело? Прикол в том,что 16 и 5 - целые числа, и операция деления вернула нам тоже целое число. Операторы +, -, *, = действуют точно как функции и результат их выполнения тоже строго типизирован. 
   Есть несколько способов исправить дело. Первый - явно указать компилятору, что мы хотим использовать числа с дробями. Вот так:

   float x = 16.0 / 5.0;

    Компилятор видит точки, отделяющие целую часть от дробной, и результатом деления, записанным в Х, будет 3.2.
   Другой способ заключается в применении операции, которая называется "приведением типа". Это когда мы заставляем вместо одного типа использовать другой.

   float x = (float) 16 / 5;

   Тут мы предваряем 16 типом float, заключенным в скобки. Это значит, что 16 превратится в 16.0, приведётся к дробному типу float. После чего компилятор автоматически приведет к тому же типу правый операнд деления, 5. И 5 тоже станет 5.0.
   Если хоть один из операндов дробный, к дробному типу автоматически будет приведен и второй операнд.
   Посмотрим полный пример, 08-02.cpp, и попробуем откомпилировать и запустить программу:


#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
   float x = 16 / (float) 5;

   cout << x << endl;

   return 0;
}


   Такой синтаксис, где название типа заключено в скобки и служит для выполнения приведения типа, присущ языку программирования Си, предшественнику С++. 
   Более присущий С++ способ приведения типа похож на вызов функции. Именем функции служит имя типа, а указываемым в скобках параметром - приводимое к типу значение:

   float x = float (16) / 5;

   Наконец третий способ, который вы сейчас явно не захотите использовать:

   float x = static_cast<float> (16) / 5;

   Итак, тут для приведения типа используется конструкция static_cast<имя типа> (переменная или число).
   Да, еще - делить на ноль нельзя! Программа вылетит.
   Посмотрим на примере 08-03.cpp, как в С++ работает автоматическое приведение типов:

#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
   float x = 5.5;
   int y = 5;

   cout << y + x << endl;

   return 0;
}

   Мы объявили дробную переменную X и целую Y, и потом выводим на консоль результат их сложения. Поскольку Х у нас float, дробь, то Y приводится к тому же типу, на выходе получаем 10.5.
   Напишем другой пример, 08-04.cpp:

#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
   float x = 5.5;
   int y = 5 + x;

   cout << y << endl;

   return 0;
}

   Те же переменные, но к целому Y мы прибавяем сумму из 5 и значения дробной переменной Х. Получилось бы 10.5, но Y у нас целого типа. Выводим значение одного только Y, получается 10. Заметим - 10.5 не округлилось до 11, но дробная часть просто отбросилась.
   Теперь еще кое-что про сложение и вычитание. Зачастую нужно уменьшить или увеличить значение переменной на единицу. Это удобно в разных переменных счетчиках.
   Конечно, можно написать так:

int x = 1;
x = x + 1;

   Тут х станет двойкой.
   Но можно записать это иначе, используя операторы увеличения и уменьшения ++ или --. Их называют операторами инкремента и декремента. 

int x = 1;
x++; //добавляем единицу
x--; //отнимаем единицу

   Теперь важно! Операторы ++ и -- имеют две формы, префиксную и постфиксную, то есть могут предшествовать переменнной или следовать за нею.
  Можно написать 

  x++;

или 

  ++x;

  В чем разница?
  Когда мы пишем одной строкой

  x++;

или 

  ++x;

   разницы никакой, после выполнения этой строки Х увеличится на единицу.
   Но что, если мы напишем так (08-05.cpp):

#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
   int x = 2;
   cout << x++ << endl;

  return 0;
}

   Запустим программу. Икс был равен 2, мы выводим на консоль Х, увеличивая его на единицу оператором ++.
   Вроде должно написаться 3, но выводится 2. Ошибка? Нет.
   Поставим теперь плюсы перед иксом (08-06.cpp):

#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
   int x = 2;
   cout << ++x << endl;

   return 0;
}

   Вот, теперь вывелось 3!

   Сравним две варианта:

   cout << x++ << endl;
   cout << ++x << endl;

   Что происходит в первом случае? На консоль выводится значение Х, а ЗАТЕМ к переменной применяется увеличение на единицу.
   Что происходит во втором случае? СНАЧАЛА  Х применяется операция увеличения, а затем 
это увеличиенное значение Х выводится на консоль.
   Итак, когда вы играетесь со счетчиком в отдельной строке, разницы никакой. Когда же используете ++ и -- по ходу выполнения более сложного выражения, надо учитывать, какую форму использовать, предваряющую или заключающую, то есть префиксную или постфиксную.
   Кстати, на С++ само название языка может стать выражением:

int c = 1;
c++;
   
   На сегодня всё, до следующей серии!




#### Поддержать курс:

* PayPal: peter.semiletov@gmail.com

* биткоин: 1PCo2zznEGMFJey4qFKGQ8CoFK2nzNnJJf


#### Навигация:

[Оглавление](https://psemiletov.github.io)

[Предыдущий урок](007.md)
