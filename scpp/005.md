### ПЕТР СЕМИЛЕТОВ

### ПРОСТО С++: УРОК 5

*Дальнейшие игрища с простейшей прогой и вызовом функции. Пишем полезный калькулятор процентов. Текстовый ввод - как предложить пользователю ввести текст или число?*

   Давайте для закрепления поиграемся еще с нашей простейшей программой. Напомню ее исходный код:

```cpp
#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
  cout  << "Привет!" << endl;
  
  return 0;
}
```

Для удобства можете сохранить ее в другом файле, например example05.cpp, и компилировать, как прежде, командой запуска компилятора C++: g++

```console
g++ example05.cpp
```

   На выходе получаем тот же файл a.out в Линуксе и a.exe под Вындой.

   В прошлой серии мы написали нудную функцию **sum** - сумма, в реальном мире совершенно бесполезную, однако на ее простоте проще учиться. Давайте добавим ее в нашу программу и попробуем использовать.   

   Поместим функцию **sum** перед главной функцией программы - **main**, но после **include** и **using namespace**. 

```cpp
#include <iostream>

using namespace std;

int sum (int a, int b) 
{
   return a + b;
}

int main (int argc, char *argv[])
{
  cout  << "Привет!" << endl;
  
  return 0;
}
```

   Такое помещение функции в программу называется объявлением функции. То есть мы объявляем в программе функцию, ее название и содержащиеся в теле алгоритмы. После объявления мы можем использовать функцию, обратившись, вызвав ее по имени. Поэтому функция должна быть объявлена раньше, чем использована.

   Объявлять функцию можно только вне другой функции. Если мы собираемся использовать, вызывать функцию **sum** в функции **main**, то должны объявить функцию **sum** выше по тексту программы, чем функция **main**.

   Теперь давайте добавим в нашу программу переменную икс, положим в нее результат работы функции **sum**, и выведем значение переменной икс на экран, в консоль.

   Для удобства я выложил исходник в сеть, пример называется [05-01.cpp](https://raw.githubusercontent.com/psemiletov/simple-cpp-examples/main/05-01.cpp). 

```cpp
#include <iostream>

using namespace std;

int sum (int a, int b) 
{
   return a + b;
}

int main (int argc, char *argv[])
{
  int x = sum (3, 4);
  cout  << "Значение x равно: " << x << endl;
  
  return 0;
}
```

  Сначала, в первой строчке функции **main**, мы объявили переменную икс типа **int** и присвоили ей оператором присваивания, знаком "=",  значение, число, которое вернула функцию **sum**. В эту функцию мы передаем в параметрах два числа, 3 и 4 - их-то функция и сложит.

  Затем мы последовательно скармливаем объекту **cout**, консольному выводу, сначала текст "Значение x равно: ", потом переменную **x**, и наконец знаменитый **endl**, указывающий на перевод строки.

   Когда объект **cout** получает переменную, он выводит на экран ее значение. В переменной иск у нас лежит то, что вернула функция **sum**.

   Можно ли написать нашу программу более кратко? Да.

```cpp
#include <iostream>

using namespace std;

int sum (int a, int b) 
{
   return a + b;
}

int main (int argc, char *argv[])
{
  cout  << "Значение x равно: " << sum (3, 4) << endl;

  return 0;
}
```

   Мы обошлись без промежуточной переменной икс, и просто скормили **cout**'у значение, возвращаемое функцией **sum**. Итак, функцию можно использовать как своеобразную переменную, значение которой вычисляется внутри ее.

   Между прочим, могут быть функции, которые не принимают параметры, но возвращают какое-то значение. Немного отвлечемся от основной темы. Напишем функцию, которая будет возвращать число 13. Функцию назовем **N13**:

```cpp
int N13()
{
  return 13;
}  
```

  Итак, круглые скобки после имени функции должны стоять, но оставаться пустыми, если параметров нет.

  Целесообразность таких функций велика, подобной функцией может быть, допустим, получение текущего времени или состояния нажатия кнопок на клавиатуре. Но вернемся к нашей программе.

  Может ли мы еще более сократить ее? Да.

```cpp
#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
  cout  << "3 + 4 равно " << 3 + 4 << endl;

  return 0;
}
```

   Мы вообще выкинули функцию **sum** и передаем на консольный вывод сумму чисел 3 и 4 напрямую.

   Это приводит к мысли, что можно написать простенькую программу-калькулятор, но так, чтобы с пользой. 

   Иногда у каждого человека возникает потребность подсчитать, сколько означает столько-то процентов от числа. Например, банк платит 3 процента годовых, а вы положили в банк замысловатую сумму, ну там, например, 555 денег.  

  Человек в таком случае достает смартфон и пытается на тамошнем калькуляторе вычислить эти три процента, но непонятно что и как нажимать. Наконец после совещания с родственниками человек окончательно запутывается и лезет в сеть в поиске какого-то особого калькулятора процентов. 

   А мы сейчас напишем сами такой калькулятор на С++.

   Формула вычисления проста. Чтобы узнать, чему равно столько-то процентов от числа, надо взять число, умножить его на проценты и разделить на сто.

   Что еще нам нужно? Чтобы пользователь мог вводить в нашу программу два значения - число, из которого мы вычисляем проценты, и сами проценты.

   Вы уже знаете про объект вывода на экран, на консоль - **cout** - console out. Есть парный объект, консольного ввода, console in, и называется он **cin**! Он-то и понадобится нам, чтобы пользователь мог вводить значения с клавиатуры.

   Итак, код программы - [файл 05-02.cpp](https://raw.githubusercontent.com/psemiletov/simple-cpp-examples/main/05-02.cpp):

```cpp
#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
  float number;
  float percents;

  cout  << "Введите число: " << endl;
  cin >> number;
  cout  << "Введите проценты: " << endl;
  cin >> percents;

  cout  << "Результат: " << number * percents / 100 << endl;

  return 0;
}
```

   Сначала мы объявляем две переменные:

```cpp
  float number; //сюда мы возьмем у пользователя число

  float percents; //а сюда проценты
```

   Объект **cout** мы по-прежнему используем для взаимодействия с пользователем, выводя ему разный текст. Сначала, выражением 

```cpp
cout  << "Введите число: " << endl;
```

...мы предлагаем пользователю ввести число. Теперь точка выполнения программы достигла выражения

```cpp
cin >> number;
```

   Тут мы считываем из консольного ввода, то есть с клавиатуры, значение, которое вводит пользователь. Программа ждет, пока пользователь введет число и нажмет Энтер.

   Видите оператор перенаправления **>>** после **cin**? В случае с **cout** мы, подобным оператором **<<** , но направленным в другую сторону, посылаем данные на выход. А здесь наоборот, мы данные с входного потока направляем в переменную **number**.

   Считав введенное пользователем число в эту переменную, мы снова выводим текст, предлагая пользователи ввести теперь проценты:

```cpp
cout  << "Введите проценты: " << endl;
```

И считываем значение уже в переменную **percents**:

```cpp
cin >> percents;
```

Итак, со входного потока мы оператором >> посылаем введенные пользователем данные в переменную **percents**.

  Теперь осталось применить формулу вычисления процентов от числа и вывести результат на экран. Вставляем формулу прямо в выражение вывода:

```cpp
cout  << "Результат: " << number * percents / 100 << endl;
```

То есть, значение переменных **number** и **percents** - то, что ввел с клавиатуры пользователь, то что хранится в этих переменных, мы перемножаем и результат умножения делим на сто, а затем полученное выводим на консоль.

   Но любую программу можно улучшить. Вот тут мне не нравится, что после каждого запроса ввести значение происходит переход на новую строку. Давайте кое-что поменяем, чтобы переход на новую строку происходил уже после того, как пользователь ввел очередное число.

   Пример [05-03.cpp](https://raw.githubusercontent.com/psemiletov/simple-cpp-examples/main/05-03.cpp):

```cpp
#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
  float number;
  float percents;

  cout  << "Введите число: ";
  cin >> number;
  cout  << endl;
  cout  << "Введите проценты: ";
  cin >> percents;
  cout  << endl;

  cout  << "Результат: " << number * percents / 100 << endl;

  return 0;
}
```

   Видите разницу? Мы не посылаем **endl** на консольный вывод сразу после текста. Вместо этого, мы ждем, пока пользователь введет число - получаем его из потокового объекта **cin**, и только затем мы посылаем на вывод **endl**, чтобы добиться перевода на новую строку. Программа становится чуть длиннее, зато работать с ней приятнее.

   Что же, наконец мы написали рабочую и более-менее полезную программу. Можете ею даже пользоваться, ведь у вас есть готовый исполняемый файл.

   Однако в этой программе нет того, что грубо называется защитой от дурака. Или, более вежливо - защитой от нецелевого использования. По злому умыслу или случайности пользователь вместо чисел может ввести буквы!

   Что случится при этом с выполнением программы в том виде, как она сейчас написана? Она сглючит. Если при первом запросе ввести какие-нибудь буквы вместо цифр, наша программа не даст уже ввести проценты и быстренько проскачет к своему завершению.

   Очевидно, необходимо ввести некую проверку. А для этого надо научить программу рассуждать при помощи логических выражений. Если пользователь ввел не число, а буквы, сообщаем об ошибке, иначе продолжаем выполнять программу как положено. Для таких рассуждений в С++ есть особые ключевые слова языка, **if** и **else**, что в переводе означает если и иначе.

   Но об этом мы поговорим позже. Движемся шаг за шагом, постигая всё новое и расширяя наши возможности. 

   И как видим, С++ позволяет писать действительно простые программы, которые можно использовать сразу после компиляции, получив настоящий исполняемый файл. 

   А как обстоят дела с другими языками программирования? Возьмем к примеру модный нынче JavaScript. По большому счету, вы не можете на нем написать отдельную программу. Вы можете написать программу, которая работает внутри веб-браузера, выполняется им, а не операционной системой. 

   В браузере эту программу будет выполнять особая программа, движок JavaScript. В браузере Хром таковой движок называется V8. Он существует в виде и отдельной программы, Node.js, которая позволяет отвязать программы на JavaScript от браузера, однако без Node.js ваша программа работать не будет.

   Кстати, на чем написан этот движок? Догадайтесь. Конечно, на С++. 

   Но давайте посмотрим, как будет выглядеть наш калькулятор процентов, если его написать на JavaScript и не заморачиваться с Node.js. Для этого нам придется создать HTML-страницу, файл, и поместить скрипт в него. [Исходник лежит тут](https://raw.githubusercontent.com/psemiletov/simple-cpp-examples/main/05-test.html). Можете потом загрузить этот файл в браузер и проверить, как работает скрипт.

```html
<!doctype html>
<html>

<body>

<script>
var number = prompt ("Введите число:");
var percents = prompt ("Введите проценты:");
document.write ("Результат: " + number * percentsy / 100);
</script>

</body>
</html> 
```

   Ключевое слово **var** указывает, что мы объявляем переменную. Как видим, JavaScript в этом случае забирает у нас право самим выбирать, какого типа эта переменная - число ли, строка ли. Это движок определит позже, когда попробует вычислять формулу.

   Слово **prompt** выводит окошко для ввода значения. Мы считываем сначала значение по запросу "Введите число" и пишем его в переменную **number**, затем проделываем соответственное для переменной **percents**.

   Затем, дабы написать на веб-странице результат вычисления нашей формулы процентов, мы обращаемся к функции **write** (писать) объекта **document**:

```java
document.write 
```

   Казалось бы, тоже простая программа. Но почему для написания сложных программ используют С++, а не JavaScript? 

   Ответ не только в быстроте и автономности выполнения программ на С++. На С++ можно писать сложные программы так, что они остаются простыми и понятными для программиста. А на скриптовых языках вроде JavaScript, с усложнением возможностей программы, ее исходный код становится слишком громоздким и труднопонятным.


#### Поддержать курс:

* PayPal: peter.semiletov@gmail.com

* биткоин: 1PCo2zznEGMFJey4qFKGQ8CoFK2nzNnJJf


#### Навигация:

[Оглавление](https://psemiletov.github.io)

[Предыдущий урок](004.md)

